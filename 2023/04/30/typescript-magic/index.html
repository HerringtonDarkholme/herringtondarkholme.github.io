<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Into the Chamber of Secrets, Break through the limits of TypeScript | Abitrarily Idiosyncratic Randomness</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <meta name="description" content="This is a rewrite of the zhihu article. Permission has been granted.The original author of this article is finding a job, find him on GitHub.  What’s Type level programming, a.k.a type gymnastics?Typ">
<meta property="og:type" content="article">
<meta property="og:title" content="Into the Chamber of Secrets, Break through the limits of TypeScript">
<meta property="og:url" content="https://herringtondarkholme.github.io/2023/04/30/typescript-magic/index.html">
<meta property="og:site_name" content="Abitrarily Idiosyncratic Randomness">
<meta property="og:description" content="This is a rewrite of the zhihu article. Permission has been granted.The original author of this article is finding a job, find him on GitHub.  What’s Type level programming, a.k.a type gymnastics?Typ">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic1.zhimg.com/v2-7fac8439827a5a3e618f7faba7c5dfb8_r.jpg">
<meta property="article:published_time" content="2023-05-01T05:26:14.000Z">
<meta property="article:modified_time" content="2023-05-08T04:29:13.327Z">
<meta property="article:author" content="Herrington Darkholme">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-7fac8439827a5a3e618f7faba7c5dfb8_r.jpg"><meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">Abitrarily Idiosyncratic Randomness</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-typescript-magic" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      Into the Chamber of Secrets, Break through the limits of TypeScript
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2023-05-01T05:26:14.000Z" itemprop="datePublished">April 30, 2023, 10:26 PM</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <blockquote>
<p>This is a rewrite of the <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/613266541">zhihu article</a>. Permission has been granted.<br><em>The original author of this article is finding a job, <a target="_blank" rel="noopener" href="https://github.com/fightingcat">find him on GitHub</a>.</em></p>
</blockquote>
<h1 id="What’s-Type-level-programming-a-k-a-type-gymnastics"><a href="#What’s-Type-level-programming-a-k-a-type-gymnastics" class="headerlink" title="What’s Type level programming, a.k.a type gymnastics?"></a>What’s Type level programming, a.k.a type gymnastics?</h1><p>TypeScript is a powerful and expressive language that allows you to write complex yet elegant code. Some TypeScript users love to explore the possibilities of the type system and love to encode logic at type level.<br>This practice, as we have a slang for it, is known as <em>type gymnastics</em>. Type gymnastics can help you to perform various tasks such as parsing, validating, transforming, or computing values based on types. Type gymnastics often requires the users mastering a wide range of advanced TypeScript features such as conditional types, recursive types, template literal types, mapped types and more. The community also helps users to learn type gymnastics by creating fun and challenges such as <a target="_blank" rel="noopener" href="https://tsch.js.org/">type challenges</a>.</p>
<p>You can proudly call yourself a TypeScript magician if you can solve most of the type challenges!</p>
<p>The type-level programming community has been creating all kinds of amazing tricks ever since the introduction of template literal type in version 4.1. Some enthusiasts have pushed this hobby to the extreme, and even tried to reimplement TypeScript at compile-time using pure types!</p>
<p>However, there are still three major obstacles that prevent TypeScript becoming a true <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/14833">turing complete machine (#14833)</a>. They are:</p>
<ul>
<li>tail recursion count: the maximum number of recursive calls in a conditional type.</li>
<li>type instantiation depth: the maximum depth when we instantiate a generic type alias.</li>
<li>type instantiation count: the maximum number of type instantiations.</li>
</ul>
<p>These limits are not arbitrary. The compiler has set a maximum limit for these three values and will throw an error <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/1416053b9e85ca2344a7a6aa10456d633ea1cd65/src/compiler/diagnosticMessages.json#L2718">TS2589</a> if we exceed them to prevent the compiler from hanging or crashing.<br>They are the walls that stop us from breaking through the limits of TypeScript compiler. But, there is actually a hidden layer behind the wall, if we explore the compiler source code carefully.</p>
<blockquote>
<p>Doing type level programming is like casting magic, but breaking through the wall of type gymnastics is like finding the hidden chamber of secrets that contains the most powerful and dangerous type of all.</p>
</blockquote>
<h2 id="Some-digression-for-background…"><a href="#Some-digression-for-background…" class="headerlink" title="Some digression for background…"></a>Some digression for background…</h2><p>Back then three years ago, I wrote <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86008532">an article</a> about how to implement a recursive descent parser. At that time, there was no template literal type, and a lot of type system limitations have been lifted since then. Crafting a code interpreter using recursive descent parsing would easily exceed the compiler’s limit.</p>
<p>So I decided to switch to a bottom-up parsing method to more easily bypass the limit, with some tricks :). Later, as TypeScript gradually evolves, newly added features opened unprecedented possibilities of type gymnastics. This finally gave me a chance to implement a <a target="_blank" rel="noopener" href="https://github.com/fightingcat/sits">type gymnastics parser generator for LALR(1) grammar</a> to generate a parser for a subset of JavaScript syntax.<br>I designed a special purpose <em>“bytecode”</em> for the ease of type level execution and directly compiled the input code into the bytecode during the parsing process(I still have some unfinished work left, procrastinating now…). My ultimate goal is to implement a type level scripting language that can execute sufficiently complex code.</p>
<p>To achieve this goal, I need to solve all the three limitations mentioned above to run lunatic code patterns, to some extent, at compile time!</p>
<p><img src="https://pic1.zhimg.com/v2-7fac8439827a5a3e618f7faba7c5dfb8_r.jpg" alt="Type Level Programming nowadays can represent monsters like this..."></p>
<h1 id="Tail-Recursion-Count"><a href="#Tail-Recursion-Count" class="headerlink" title="Tail Recursion Count"></a>Tail Recursion Count</h1><p>Let’s look at the first limitation, the type tail recursion count (tailCount). Type level programming often uses recursive types. Before the previous versions supported recursive types, we usually <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/14833">implemented recursion</a> by combining mapped types, recursive type definitions and index types. Ever since we had <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/33050">recursive types</a> and <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/45711">tail recursion of type instantiation</a>, this kind of type gymnastics became much more elegant, but at the same time we also got this tail recursion count limitation.</p>
<p>Searching for <code>tailCount</code> in the TypeScript source code, we can see that the implementation is related to computing conditional types. Let’s simplify the code a bit and take a look (sorry folks, I cannot get a link to GitHub source code due to checker.ts is too large):</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transitively used in instantiateType</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getConditionalType</span>(<span class="params">root: ConditionalRoot</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">let</span> tailCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tailCount === <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="title function_">error</span>(<span class="number">2589</span>);</span><br><span class="line">            result = errorType;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// false branch</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isTypeAssignableTo</span>(checkType, extendsType)) &#123;</span><br><span class="line">            <span class="keyword">const</span> falseType = <span class="title function_">getTypeFromTypeNode</span>(root.<span class="property">node</span>.<span class="property">falseType</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">canTailRecurse</span>(falseType)) &#123;</span><br><span class="line">                <span class="comment">// root = falseType;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tail call terminates, creating new type</span></span><br><span class="line">            result = <span class="title function_">instantiateType</span>(falseType);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// true branch</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isTypeAssignableTo</span>(checkType, extendsType)) &#123;</span><br><span class="line">            <span class="keyword">const</span> trueType = <span class="title function_">getTypeFromTypeNode</span>(root.<span class="property">node</span>.<span class="property">trueType</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">canTailRecurse</span>(trueType)) &#123;</span><br><span class="line">                <span class="comment">// root = trueType;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// end of tail recursion, instantiate new type</span></span><br><span class="line">            result = <span class="title function_">instantiateType</span>(trueType);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">canTailRecurse</span>(<span class="params">newType: Type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newType.<span class="property">flags</span> &amp; <span class="title class_">TypeFlags</span>.<span class="property">Conditional</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newRoot = (newType <span class="keyword">as</span> <span class="title class_">ConditionalType</span>).<span class="property">root</span>;</span><br><span class="line">            <span class="keyword">const</span> newCheckType = newRoot.<span class="property">isDistributive</span></span><br><span class="line">                ? newRoot.<span class="property">checkType</span></span><br><span class="line">                : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                !newCheckType ||</span><br><span class="line">                !(newCheckType.<span class="property">flags</span> &amp; (<span class="title class_">TypeFlags</span>.<span class="property">Union</span> | <span class="title class_">TypeFlags</span>.<span class="property">Never</span>))</span><br><span class="line">            ) &#123;</span><br><span class="line">                root = newRoot;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newRoot.<span class="property">aliasSymbol</span>) &#123;</span><br><span class="line">                    tailCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that as long as the branch of the conditional type that matches is another conditional type, and the new conditional type is neither a distributive conditional type nor a union type or never, then the new conditional type will be substituted into the next round of computation.</p>
<p>The only problem is that it will trigger an error TS2589 when the loop reaches 1000 times, <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play#code/C4TwDgpgBAWhBOB7AYgSwDboDwCgr6gHkBXYMUqCAD2AgDsATAZygAYBtAXQBo8CBhRMTrBKNesyh1iAWwBGCHAD4oAXiKlywdgCJ09AObAAFjs5jajFoOGiA-BrIUAXLAQoM2dgDpfJJ8DcbDxQNiJKANw4OKCQUADKqABeEAwAnBlqbkhomFhcQRlpkVAA9KVEANYAhiDeMeDQiSkMAIwA0llwOZ75Ia2sgyXlRIhgTEEAKvEATACsABxp9UA">TS Playground</a>:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ZeroFill</span>&lt;</span><br><span class="line">    <span class="title class_">Output</span> <span class="keyword">extends</span> <span class="number">0</span>[],</span><br><span class="line">    <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">&gt; = <span class="title class_">Output</span>[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> <span class="title class_">Count</span> ? <span class="title class_">Output</span> : <span class="title class_">ZeroFill</span>&lt;[...<span class="title class_">Output</span>, <span class="number">0</span>], <span class="title class_">Count</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized999</span> = <span class="title class_">ZeroFill</span>&lt;[], <span class="number">999</span>&gt;; <span class="comment">// Okay.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized1K</span> = <span class="title class_">ZeroFill</span>&lt;[], <span class="number">1000</span>&gt;; <span class="comment">// Oops, TS2589.</span></span><br></pre></td></tr></table></figure>

<p>To avoid reaching the 1000 times recursion limit, we can deliberately break the tail recursion after a certain number of recursions (using an extra parameter to count), as long as we return a type that does not satisfy the above conditions, and does not affect the result of the type we return, such as returning an intersection type (<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play#code/PTAEAkEMCcBMFoDGB7WBTUlQDsCuBbAIzWk2mkgE8AaMiy0AS23QA9QVy0BnAB2RbdQAF2SgAbpAA2uDLxlCAjAChhlXhgCS2RKQC8oANrLQpxbVAAmCwGYLAFgsBWCwDYLAdgsAOCwE5aRQAGQPNQRWtwu3DHcJdw93CvcN9wgKsQkyswy0jLaMtYy3jLRMtky1TLdJsQ0Bswm0ibaJtYm3ibRJtkm1SbdPtM03sw+0j7aPtY+3j7RPtk+1T7dKc6pzCnSKdop1ineKdEp2SnVKd012HQVzDXSNdo11jXeNdE12TXVNd0jzqHjCHkiHmiHliHniHkSHmSHlSHnS3hu3jC3ki3mi3li3ni3kS3mS3lS3nSfjqfjCfkifmiflifnifkSfmSflSfnSwRumQAugBuZSqdQYABaJGQADFGFIpAAeLKmADyuGEvDVoDQrGEaEEoCChj51CVoAAwshcNhhFqdXrYEI8EQSCbTKZNLqKMJGAIhNrdfrtLpDE7iNA+aADEFlAA+SOgD0kSDe322gMO8JBaNu0AAflAIHNAAtINgAOYYYRFjDQNCIXDQbiMcSV0UiMSlpjWkjcOsp7AiUW0Qi1yAAaxE1ZEkFloFr9cbPoHpdgc54aBtVYwjE9yaXptMEug0tlCtV6rVtAtVuEtCCcYAZKAAN4AX1NAC4C2AAEp1htNgIIgkPgzDJjwprnhqwiGAARFIepllWsERv69pCNe1qmvmhYytg0igH+3C4FIwgHqAUFqp+34Jjotb4Hqm5TigN6gAAZsgpBoJAiBFmuC6Adg5FHiecryoYAB0UmUbeBrGualrWrQQbQIYiZeku3B8jGQoihooAAMqMAAXmgsA2AA0vGIkymJRq0LUWY6TRypjlQEl6RgRmmbA9hWQYNmnuJ8lDE5AouW5NCgIQmpVowQjxTgyBMRg9qgMgbGgNwojQJQUkeUAA">Playground Link</a>):</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hard-code a number array, array index corresponds to value plus 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Incr</span> = [</span><br><span class="line">   <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>,</span><br><span class="line">  <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>,</span><br><span class="line">  <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>,</span><br><span class="line">  <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>,</span><br><span class="line">  <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ZeroFill</span>&lt;</span><br><span class="line">    <span class="title class_">Output</span> <span class="keyword">extends</span> <span class="number">0</span>[],</span><br><span class="line">    <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="title class_">Iterations</span> <span class="keyword">extends</span> <span class="title class_">Incr</span>[<span class="built_in">number</span>] = <span class="number">0</span></span><br><span class="line">&gt; = <span class="title class_">Iterations</span> <span class="keyword">extends</span> <span class="number">100</span></span><br><span class="line">    ? <span class="comment">// Change the recursive type to an intersection type, break the tail recursion and reset the iteration</span></span><br><span class="line">      <span class="title class_">ZeroFill</span>&lt;<span class="title class_">Output</span>, <span class="title class_">Count</span>, <span class="number">0</span>&gt; &amp; &#123;&#125;</span><br><span class="line">    : <span class="comment">// Recursion terminates</span></span><br><span class="line">    <span class="title class_">Output</span>[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> <span class="title class_">Count</span></span><br><span class="line">    ? <span class="comment">// Final Result</span></span><br><span class="line">      <span class="title class_">Output</span></span><br><span class="line">    : <span class="comment">// Increment the count for each recursion</span></span><br><span class="line">      <span class="title class_">ZeroFill</span>&lt;[...<span class="title class_">Output</span>, <span class="number">0</span>], <span class="title class_">Count</span>, <span class="title class_">Incr</span>[<span class="title class_">Iterations</span>]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized3K</span> = <span class="title class_">ZeroFill</span>&lt;[], <span class="number">3000</span>&gt;; <span class="comment">// Okay.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized4K</span> = <span class="title class_">ZeroFill</span>&lt;[], <span class="number">4000</span>&gt;; <span class="comment">// Okay, but this is not the end of story...</span></span><br></pre></td></tr></table></figure>

<h1 id="Type-Instantiation-Depth"><a href="#Type-Instantiation-Depth" class="headerlink" title="Type Instantiation Depth"></a>Type Instantiation Depth</h1><p>The type above has now exceeded the limit of 1000 recursions, but if you comment out <code>Sized3K</code>, you will see that <code>Sized4K</code> will trigger TS2589. This is related to the second limitation, which is the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/45025">type instantiation depth</a> (<code>instantiationDepth</code>). The reason why commenting out has an effect is because TypeScript will cache all instantiated types, which we will discuss later. Again, we can search for <code>instantiationDepth</code> in the TS source code. You can see that it is implemented with all types that have type mapping. There are several kinds of type mapping. For example, types that use generic parameters will have type mapping to map parameters to actual types. The relevant code is simplified as follows:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instantiateType</span>(<span class="params"><span class="keyword">type</span>?: Type, mapper?: TypeMapper</span>): <span class="title class_">Type</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">type</span> &amp;&amp; mapper ? <span class="title function_">instantiateTypeWithAlias</span>(<span class="keyword">type</span>, mapper) : <span class="keyword">type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">instantiateTypeWithAlias</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">type</span>: Type,</span></span><br><span class="line"><span class="params">    mapper: TypeMapper,</span></span><br><span class="line"><span class="params">    aliasSymbol?: <span class="built_in">Symbol</span>,</span></span><br><span class="line"><span class="params">    aliasTypeArguments?: <span class="keyword">readonly</span> Type[]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (instantiationDepth === <span class="number">100</span> || instantiationCount &gt;= <span class="number">5000000</span>) &#123;</span><br><span class="line">        <span class="title function_">error</span>(<span class="number">2589</span>);</span><br><span class="line">        <span class="keyword">return</span> errorType;</span><br><span class="line">    &#125;</span><br><span class="line">    totalInstantiationCount++;</span><br><span class="line">    instantiationCount++; <span class="comment">// note: `count` only increments</span></span><br><span class="line">    instantiationDepth++;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title function_">instantiateTypeWorker</span>(</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        mapper,</span><br><span class="line">        aliasSymbol,</span><br><span class="line">        aliasTypeArguments</span><br><span class="line">    );</span><br><span class="line">    instantiationDepth--; <span class="comment">// note: only depth got decremented</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We also see the <code>instantiationCount</code> mentioned at the beginning, but we will first focus on the <code>instantiationDepth</code> for now. We can see that before and after each type alias instantiation, the instantiation depth will increase and decrease, and any call to instantiateType in the middle process will indirectly call the above type, which will make the depth count continue to increase.<br>To avoid reaching the maximum depth, one is to use tail recursion as much as possible, and the other is to reduce the dependence on intermediate types in the recursive process if you use the technique of breaking tail recursion before.<br>Here is an example code (to reduce interference we simplify it to only have two generic parameters, only keep the recursive logic itself, and use intersection type to prevent tail recursion instantiation):</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simulate a type that keeps calculating values and sets the finish state based on the results</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BadWay</span>&lt;<span class="title class_">State</span>, <span class="title class_">Value</span>&gt; = <span class="title class_">State</span> <span class="keyword">extends</span> <span class="string">`finish`</span></span><br><span class="line">    ? <span class="title class_">Value</span></span><br><span class="line">    : <span class="comment">// Use conditional type and infer type to save the new result</span></span><br><span class="line">    <span class="title class_">Calculate</span>&lt;<span class="title class_">Value</span>&gt; <span class="keyword">extends</span> infer <span class="title class_">NewValue</span></span><br><span class="line">    ? <span class="comment">// Use conditional type and infer type to save the new state</span></span><br><span class="line">      <span class="title class_">CheckValue</span>&lt;<span class="title class_">NewValue</span>&gt; <span class="keyword">extends</span> infer <span class="title class_">NewState</span></span><br><span class="line">        ? <span class="comment">// Compared to direct recursion, this adds two levels of type instantiation depth</span></span><br><span class="line">          <span class="title class_">BadWay</span>&lt;<span class="title class_">NewState</span>, <span class="title class_">NewValue</span>&gt;</span><br><span class="line">        : <span class="built_in">never</span></span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In fact, repeating “calling” type aliases does not lose anything, TS will always cache all types instances.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GoodWay</span>&lt;<span class="title class_">State</span>, <span class="title class_">Value</span>&gt; = <span class="title class_">State</span> <span class="keyword">extends</span> <span class="string">`finish`</span></span><br><span class="line">    ? <span class="title class_">Value</span></span><br><span class="line">    : <span class="comment">// Direct recursion reduces the instantiation depth as much as possible</span></span><br><span class="line">      <span class="title class_">GoodWay</span>&lt;</span><br><span class="line">          <span class="comment">// The intermediate result is instantiated when passing parameters, which can be instantiated before recursion, releasing the increased depth.</span></span><br><span class="line">          <span class="title class_">CheckValue</span>&lt;<span class="title class_">Calculate</span>&lt;<span class="title class_">Value</span>&gt;&gt;,</span><br><span class="line">          <span class="comment">// The repeated alias calls will only be truly instantiated once due to the caching mechanism, so you don’t have to worry about various restrictions and overheads.</span></span><br><span class="line">          <span class="title class_">Calculate</span>&lt;<span class="title class_">Value</span>&gt;</span><br><span class="line">      &gt; &amp; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>In the example above, <code>BadWay</code> increases the depth by two levels more than <code>GoodWay</code> for each recursion, which will reach the recursion depth limit faster.</p>
<p>With the instantiation level limit, we should <strong>start recursion as early as possible</strong>, putting all kinds of intermediate type calculations into parameters. And let each iteration type complete instantiation as soon as possible, releasing the increased depth.</p>
<p>Another way to release the depth count in advance is to manually <strong>split the iteration process into multiple parts</strong>, storing intermediate result as a type alias.<br>Let’s take the first type as an example:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Sized3K</span> = <span class="title class_">ZeroFill</span>&lt;[], <span class="number">3000</span>&gt;; <span class="comment">// Okay.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized4K</span> = <span class="title class_">ZeroFill</span>&lt;<span class="title class_">Sized3K</span>, <span class="number">4000</span>&gt;; <span class="comment">// Okay.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sized5K</span> = <span class="title class_">ZeroFill</span>&lt;<span class="title class_">Sized4K</span>, <span class="number">5000</span>&gt;; <span class="comment">// Okay.</span></span><br></pre></td></tr></table></figure>

<p>One thing to keep in mind is that as the type becomes more complex, the tsc compiler may handle it fine, but the editor may not give any feedback due to the long response time. This is because they use different methods and caches for type checking. For example, in the code above, if we comment out <code>Sized4K</code> (which has a cache effect), and directly generate <code>Sized5K</code> from <code>Sized3K</code>, we will get a <code>TS2589</code> error again. See <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play#code/PTAEAkEMCcBMFoDGB7WBTUlQDsCuBbAIzWk2mkgE8AaMiy0AS23QA9QVy0BnAB2RbdQAF2SgAbpAA2uDLxlCAjAChhlXhgCS2RKQC8oANrLQpxbVAAmCwGYLAFgsBWCwDYLAdgsAOCwE5aRQAGQPNQRWtwu3DHcJdw93CvcN9wgKsQkyswy0jLaMtYy3jLRMtky1TLdJsQ0Bswm0ibaJtYm3ibRJtkm1SbdPtM03sw+0j7aPtY+3j7RPtk+1T7dKc6pzCnSKdop1ineKdEp2SnVKd012HQVzDXSNdo11jXeNdE12TXVNd0jzqHjCHkiHmiHliHniHkSHmSHlSHnS3hu3jC3ki3mi3li3ni3kS3mS3lS3nSfjqfjCfkifmiflifnifkSfmSflSfnSwRumQAugBuZSqdQYABaJGQADFGFIpAAeLKmADyuGEvDVoDQrGEaEEoCChj51CVoAAwshcNhhFqdXrYEI8EQSCbTKZNLqKMJGAIhNrdfrtLpDE7iNA+aADEFlAA+SOgD0kSDe322gMO8JBaNu0AAflAIHNAAtINgAOYYYRFjDQNCIXDQbiMcSV0UiMSlpjWkjcOsp7AiUW0Qi1yAAaxE1ZEkFloFr9cbPoHpdgc54aBtVYwjE9yaXptMEug0tlCtV6rVtAtVuEtCCcYAZKAAN4AX1NAC4C2AAEp1htNgIIgkPgzDJjwprnhqwiGAARFIepllWsERv69pCNe1qmvmhYytg0igH+3C4FIwgHqAUFqp+34Jjotb4Hqm5TigN6gAAZsgpBoJAiBFmuC6Adg5FHiecryoYAB0UmUbeBrGualrWrQQbQIYiZeku3B8jGQoihooAAMqMAAXmgsA2AA0vGIkymJRq0LUWY6TRypjlQEnKIWaj6UZpmwPYVkGDZp7yr5ZmWbQQxOQKLluZQHneRgYWwE4gWgMFYnJRFoDrNFsXucoQA">the playground link</a>.This is not caused by the two limitations we mentioned before, because this time we only have 2000 iterations, much less than <code>Sized3K</code>. The actual cause of this compilation error leads us to the third limitation: the type instantiation count (<code>instantiationCount</code>).</p>
<h1 id="Type-Instantiation-Count"><a href="#Type-Instantiation-Count" class="headerlink" title="Type Instantiation Count"></a>Type Instantiation Count</h1><p>We have encountered the variable <code>instantiationCount</code> before in the function <code>instantiateTypeWithAlias</code>. It has a current limit of <code>5,000,000</code>, which is incremented together with <code>instantiationDepth</code> every time a type is instantiated. Unlike <code>instantiationDepth</code>, it does not decrease when the instantiation is done because it represents the number of type instances that are created in one instantiation process. If we continue to search the source code, we can see that it is set to 0 when the compiler checks some types of syntax nodes:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkSourceElement</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    instantiationCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkDeferredNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    instantiationCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkExpression</span>(<span class="params">node, checkMode, forceTuple</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    instantiationCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>If we debug tsc and set a breakpoint after the condition <code>instantiationCount &gt;= 5000000</code>, we will see in the call stack that the error is thrown when instantiating an object type with more than 3700 members. This object type is actually the array type that we generated. We will not analyze step by step why it produces so many (5 million) type instances here. We just need to know that this array is created by many generic parameters, which leads to a large number of type instances. Even if our type gymnastics did not generate such a large array, it would slow down the speed when producing so many type instances. So how can we avoid this situation?</p>
<p>The direct conclusion is to use other types to achieve the purpose according to the needs. For example, if you use an array type to simulate a stack structure, and only need to access the last one or a few elements, then you can define a List object type, which is concatenated, but the structure of the object is fixed:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">List</span>&lt;T&gt; = &#123; <span class="attr">data</span>: T; <span class="attr">prev</span>: <span class="title class_">List</span>&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Append</span>&lt;P <span class="keyword">extends</span> <span class="title class_">List</span>&lt;<span class="built_in">unknown</span>&gt;, T&gt; = &#123; <span class="attr">data</span>: T; <span class="attr">prev</span>: P &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stack</span> = <span class="title class_">Append</span>&lt;<span class="title class_">Append</span>&lt;<span class="title class_">Append</span>&lt;<span class="built_in">never</span>, <span class="number">1</span>&gt;, <span class="number">2</span>&gt;, <span class="number">3</span>&gt;; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Popped</span> = <span class="title class_">Stack</span>[<span class="string">&quot;prev&quot;</span>]; <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Last</span> = <span class="title class_">Stack</span>[<span class="string">&quot;data&quot;</span>]; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SecondToLast</span> = <span class="title class_">Stack</span>[<span class="string">&quot;prev&quot;</span>][<span class="string">&quot;data&quot;</span>]; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Alternatively we can encode the logic in string by constructing template string of a specific format.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Append</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>, T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>,<span class="subst">$&#123;S&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stack</span> = <span class="title class_">Append</span>&lt;<span class="title class_">Append</span>&lt;<span class="title class_">Append</span>&lt;<span class="string">&quot;&quot;</span>, <span class="string">&quot;alpha&quot;</span>&gt;, <span class="string">&quot;beta&quot;</span>&gt;, <span class="string">&quot;gamma&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Popped</span> = <span class="title class_">Stack</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>,<span class="subst">$&#123;infer S&#125;</span>`</span> ? S : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Last</span> = <span class="title class_">Stack</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer T&#125;</span>,<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? T : <span class="built_in">never</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/fightingcat/sits/blob/fd958753c1f7514c29314fbfabab86d97075acec/lib/helpers.d.ts#L77">You can even use union types</a>. However, you need to pay attention that when union types are used in distributive conditional types, they will generate the same number of type instances as the number of elements, but they are still a better choice in many cases.</p>
<p>Usual type level programming will not trigger this limitation, so we will not describe it too much. To optimize the number of instantiations, you inevitably need to read the compiler source code, or you can add the <code>--diagnostics</code> parameter when calling <code>tsc</code>, and observe the <code>Instantiations</code> in the output, which can show how many type instances are generated in total.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>One caveat is that all tricks in the article are probably the byproduct of a specific compiler implementation and are not officially supported by the TypeScript team. And they may even be broken in the future!<br>Actually, most of these dark magics are manipulating type instantiation to make time-space trade-offs. We are nudging compiler to forget intermediate type caches (<a target="_blank" rel="noopener" href="https://harrypotter.fandom.com/wiki/Memory_Charm#cite_note-COS16-1">Obliviate!</a>), prompting it to compute more types (<a target="_blank" rel="noopener" href="https://harrypotter.fandom.com/wiki/Imperius_Curse">Imperio!</a>) and forcing it to work longer for a compilation (<a target="_blank" rel="noopener" href="https://harrypotter.fandom.com/wiki/Incarcerous_Spell">Incarcerous!</a>). All the grueling rituals for the holy grail of turing completeness!</p>
<p>However, they are still very useful in some cases and help us break the limitations of TypeScript! The snake is in the chamber of secrets, so use these lost spells wisely, my great mage!</p>
<p>If you find this article useful, I would be more than happy if you can <a target="_blank" rel="noopener" href="https://github.com/sponsors/HerringtonDarkholme/">treat me some coffee</a>.</p>
<hr>
<p><em>Translation, rewrite and title image generation are all assisted by MicroSoft Bing Chat.</em></p>

      
    </div>
    
    
    <div class="article-category">
      
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/TypeScript/" rel="tag">TypeScript</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2023/05/07/server-component/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Grok React Server Component by Quizzes
        
      </div>
    </a>
  
  
    <a href="/2023/01/23/optimize-ast-grep/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Optimize ast-grep to get 10X faster
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




</body>
</html>
